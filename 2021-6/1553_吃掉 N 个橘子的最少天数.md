# 题目

厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子：  

吃掉一个橘子。  
如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。  
如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。  

每天你只能从以上 3 种方案中选择一种方案。  
请你返回吃掉所有 n 个橘子的最少天数。

示例 1：  
输入：n = 10  
输出：4  
解释：你总共有 10 个橘子。  
第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。  
第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）  
第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。  
第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。  
你需要至少 4 天吃掉 10 个橘子。  

示例 2：  
输入：n = 6  
输出：3  
解释：你总共有 6 个橘子。  
第 1 天：吃 3 个橘子，剩余橘子数 6 - 6/2 = 6 - 3 = 3。（6 可以被 2 整除）  
第 2 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。（3 可以被 3 整除）  
第 3 天：吃掉剩余 1 个橘子，剩余橘子数 1 - 1 = 0。  
你至少需要 3 天吃掉 6 个橘子。  

示例 3：  
输入：n = 1  
输出：1  

示例 4：  
输入：n = 56  
输出：6  

提示：  
1 <= n <= 2*10^9  

## 思路

设：吃一个橘子为操作1，n/2为操作2，2n/3为操作3，操作1最不划算，应尽多采用操作2、3  
递推求解f(i) = 当前天数 + f(剩下的橘子)  
操作2：因n、n-1 > 0 必有一个是偶数，所以每次操作2之前最多需要一次操作1  
f(i) = i%2 + 1 + f(i/2) (依次为操作2之前的1操作，2操作，余下橘子需要天数)  
操作3：设操作3时 i = 3m，这之前最多有两次，3m + 1、3m + 2不能被3整除，因此每次操作3之前最多有两次操作1  
f(i) = i%3 + 1 + f(i/3)  
操作1：操作1不会连续出现，除了最后依次，每次都要跟操作2或3  
f(1) = 1  

总结为：  
f(i) = (i % 2 / i % 3，2或3操作前进行操作1的次数) + 本次(1) + f(剩余橘子i/2或i/3)  
为防止超时，使用哈希表记录计算过的值  
## code
~~~java
class Solution {
   Map<Integer, Integer> memo = new HashMap<Integer, Integer>();

    public int minDays(int n) {
        if (n <= 1) {
            return n;
        }
        // 哈希表记录计算过的值
        if (memo.containsKey(n)) {
            return memo.get(n);
        }
        // 递归求解，在2操作之前最多有一次1操作，3操作之前最多有2两次1操作，每次1操作之后必有一次2或3操作
        memo.put(n, Math.min(n % 2 + 1 + minDays(n / 2), n % 3 + 1 + minDays(n / 3)));
        return memo.get(n);
    }
}
~~~
